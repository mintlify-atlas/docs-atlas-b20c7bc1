---
title: RAM File System
description: Fast, memory-backed filesystem for temporary storage and high-performance file operations in Unikraft
---

The `ramfs` library provides a simple, RAM-based filesystem that stores all files and directories directly in memory. It offers the fastest possible file I/O at the cost of volatility and memory consumption.

## Overview

RamFS (RAM File System) is a virtual filesystem that uses system memory for storage. From a simplified perspective, each file in RamFS is essentially a buffer in memory, making it extremely fast for read and write operations.

### Key Characteristics

**Advantages:**
- Extremely fast file operations (memory-speed access)
- No block device or disk driver required
- Simple implementation and minimal overhead
- Perfect for temporary files and caches

**Limitations:**
- Data is not persistent (lost on shutdown)
- Storage limited by available memory
- No hard link support (filenames stored in node structure)

## Architecture

### Core Data Structure

The `ramfs_node` structure represents each filesystem entry:

```c
struct ramfs_node {
    struct ramfs_node *rn_next;    // Next sibling in directory
    struct ramfs_node *rn_child;   // First child (for directories)
    uint64_t          rn_ino;      // Unique inode number
    int               rn_type;     // VREG, VDIR, or VLNK
    char              *rn_name;    // File/directory name
    size_t            rn_namelen;  // Length of name
    size_t            rn_size;     // File size
    char              *rn_buf;     // File data buffer
    size_t            rn_bufsize;  // Allocated buffer size
    struct timespec   rn_ctime;    // Change time
    struct timespec   rn_atime;    // Access time
    struct timespec   rn_mtime;    // Modification time
    int               rn_mode;     // Access permissions
    bool              rn_owns_buf; // Buffer ownership flag
};
```

### Node Types

| Type | Constant | Description |
|------|----------|-------------|
| Regular file | `VREG` | Normal file with data buffer |
| Directory | `VDIR` | Container for other nodes |
| Symbolic link | `VLNK` | Link to another path |

### Design Notes

Unlike traditional Unix filesystems, RamFS stores filenames directly in the inode structure (`ramfs_node`) rather than in separate directory entries. This simplified design means:

- No dentry (directory entry) layer needed
- Faster lookups for simple directory structures
- Hard links are not supported
- Each filename is unique per node

## Configuration

### Enable RamFS

```console
$ kraft menuconfig
```

Navigate to: **Library Configuration → ramfs: simple RAM file system**

Requirements:
- `LIBVFSCORE`: VFS core interface (selected automatically)
- `LIBPOSIX_TIME`: POSIX time support (selected automatically)

### Auto-mount as Root

To use RamFS as the root filesystem:

1. **Library Configuration → vfscore: VFS Core Interface**
2. **vfscore: Configuration → Automatically mount a root filesystem (/)**
3. **Default root filesystem → RamFS**

## Usage

### Basic File Operations

Since all files are created in memory, they must be created programmatically:

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[])
{
    char buf[1024];
    int fd;
    ssize_t n;

    // Create and write to a file
    fd = open("/westworld.txt", O_RDWR | O_CREAT, 0777);
    if (fd < 0) {
        perror("open failed");
        return 1;
    }

    const char *text = "These violent delights have violent ends.";
    n = write(fd, text, strlen(text));
    if (n < 0) {
        perror("write failed");
        close(fd);
        return 1;
    }
    close(fd);

    // Read back from the file
    fd = open("/westworld.txt", O_RDONLY);
    if (fd < 0) {
        perror("open failed");
        return 1;
    }

    n = read(fd, buf, sizeof(buf) - 1);
    if (n > 0) {
        buf[n] = '\0';
        printf("%s\n", buf);
    }
    close(fd);

    return 0;
}
```

### Directory Operations

```c
#include <sys/stat.h>
#include <dirent.h>

int main(void)
{
    // Create directory structure
    mkdir("/tmp", 0755);
    mkdir("/tmp/data", 0755);
    mkdir("/tmp/logs", 0755);

    // Create files in directories
    int fd = open("/tmp/data/config.txt", O_WRONLY | O_CREAT, 0644);
    write(fd, "config data", 11);
    close(fd);

    // List directory contents
    DIR *dir = opendir("/tmp");
    if (dir) {
        struct dirent *ent;
        while ((ent = readdir(dir)) != NULL) {
            printf("Found: %s\n", ent->d_name);
        }
        closedir(dir);
    }

    return 0;
}
```

### File Metadata

```c
#include <sys/stat.h>
#include <time.h>

void print_file_info(const char *path)
{
    struct stat st;

    if (stat(path, &st) < 0) {
        perror("stat failed");
        return;
    }

    printf("File: %s\n", path);
    printf("Size: %ld bytes\n", st.st_size);
    printf("Inode: %lu\n", st.st_ino);
    printf("Mode: %o\n", st.st_mode & 0777);
    printf("Modified: %s", ctime(&st.st_mtime));
}
```

### Symbolic Links

```c
#include <unistd.h>

int main(void)
{
    // Create a file
    int fd = open("/original.txt", O_WRONLY | O_CREAT, 0644);
    write(fd, "original data", 13);
    close(fd);

    // Create symbolic link
    if (symlink("/original.txt", "/link.txt") < 0) {
        perror("symlink failed");
        return 1;
    }

    // Access via symlink
    char buf[256];
    ssize_t len = readlink("/link.txt", buf, sizeof(buf) - 1);
    if (len > 0) {
        buf[len] = '\0';
        printf("Link points to: %s\n", buf);
    }

    // Read file through symlink
    fd = open("/link.txt", O_RDONLY);
    // ... read operations work transparently

    return 0;
}
```

## Advanced Usage

### Pre-allocated Buffers

You can use pre-allocated buffers for zero-copy operations:

```c
// Allocate buffer
char *data = malloc(4096);
strcpy(data, "Pre-allocated data");

// Create file node with existing buffer
// (This requires internal API access)
struct ramfs_node *node = ramfs_allocate_node("preallocated.txt", 
                                               VREG, 0644);
node->rn_buf = data;
node->rn_bufsize = 4096;
node->rn_size = strlen(data);
node->rn_owns_buf = false; // Don't free on node destruction
```

### Memory Management

Monitor and control memory usage:

```c
#include <sys/statvfs.h>

void check_memory_usage(void)
{
    struct statvfs st;

    if (statvfs("/", &st) == 0) {
        unsigned long total = st.f_blocks * st.f_frsize;
        unsigned long free = st.f_bfree * st.f_frsize;
        unsigned long used = total - free;

        printf("Memory used: %lu KB\n", used / 1024);
        printf("Memory free: %lu KB\n", free / 1024);
    }
}
```

### Temporary File Pattern

```c
#include <stdlib.h>
#include <stdio.h>

FILE *create_tempfile(const char *pattern)
{
    char *tmpname = strdup(pattern);
    int fd = mkstemp(tmpname);
    if (fd < 0) {
        free(tmpname);
        return NULL;
    }

    FILE *f = fdopen(fd, "w+");
    free(tmpname);
    return f;
}

int main(void)
{
    // Create temporary file in ramfs
    FILE *tmp = create_tempfile("/tmp/tempXXXXXX");
    if (tmp) {
        fprintf(tmp, "Temporary data\n");
        rewind(tmp);
        
        char buf[256];
        fgets(buf, sizeof(buf), tmp);
        printf("Read: %s", buf);
        
        fclose(tmp); // File automatically deleted
    }

    return 0;
}
```

## Use Cases

### Application Cache

Store frequently accessed data in memory:

```c
// Cache initialization
void init_cache(void)
{
    mkdir("/cache", 0755);
}

// Store cache entry
void cache_set(const char *key, const void *data, size_t size)
{
    char path[256];
    snprintf(path, sizeof(path), "/cache/%s", key);

    int fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd >= 0) {
        write(fd, data, size);
        close(fd);
    }
}

// Retrieve cache entry
int cache_get(const char *key, void *data, size_t max_size)
{
    char path[256];
    snprintf(path, sizeof(path), "/cache/%s", key);

    int fd = open(path, O_RDONLY);
    if (fd < 0)
        return -1;

    ssize_t n = read(fd, data, max_size);
    close(fd);
    return n;
}
```

### Build Directory

Use as a high-speed build directory:

```c
// Setup build environment
mkdir("/build", 0755);
mkdir("/build/obj", 0755);
mkdir("/build/bin", 0755);

// Compile to ramfs for speed
system("cc -o /build/obj/main.o -c main.c");
system("cc -o /build/bin/app /build/obj/*.o");

// Copy final binary elsewhere if needed
```

### Log Buffer

Accumulate logs in memory before flushing:

```c
static FILE *log_file = NULL;

void log_init(void)
{
    log_file = fopen("/ramfs_log.txt", "w");
}

void log_message(const char *msg)
{
    if (log_file) {
        fprintf(log_file, "%s\n", msg);
        fflush(log_file);
    }
}

void log_flush_to_persistent(const char *persistent_path)
{
    // Copy ramfs log to persistent storage (e.g., 9pfs)
    if (log_file) {
        fclose(log_file);
        
        // Copy to persistent location
        FILE *src = fopen("/ramfs_log.txt", "r");
        FILE *dst = fopen(persistent_path, "w");
        
        char buf[4096];
        size_t n;
        while ((n = fread(buf, 1, sizeof(buf), src)) > 0) {
            fwrite(buf, 1, n, dst);
        }
        
        fclose(src);
        fclose(dst);
        
        log_file = fopen("/ramfs_log.txt", "w");
    }
}
```

### Shared Memory Alternative

Use files as shared memory between components:

```c
// Component A: Write data
void producer(void)
{
    int fd = open("/shared/data", O_WRONLY | O_CREAT, 0666);
    write(fd, &data, sizeof(data));
    close(fd);
}

// Component B: Read data
void consumer(void)
{
    struct data_t data;
    int fd = open("/shared/data", O_RDONLY);
    if (fd >= 0) {
        read(fd, &data, sizeof(data));
        close(fd);
        process_data(&data);
    }
}
```

### Testing and Development

Perfect for unit tests requiring filesystem operations:

```c
void test_file_operations(void)
{
    // Setup: All operations in fast ramfs
    mkdir("/test", 0755);
    
    // Test file creation
    int fd = open("/test/file.txt", O_WRONLY | O_CREAT, 0644);
    assert(fd >= 0);
    
    // Test write
    assert(write(fd, "test", 4) == 4);
    close(fd);
    
    // Test read
    char buf[10];
    fd = open("/test/file.txt", O_RDONLY);
    assert(read(fd, buf, 4) == 4);
    assert(memcmp(buf, "test", 4) == 0);
    close(fd);
    
    // Cleanup: Everything disappears on shutdown
}
```

## Performance Characteristics

### Speed

- **Read/Write**: Memory speed (no I/O overhead)
- **Seek**: O(1) - direct buffer access
- **Directory lookup**: O(n) - linear search through siblings
- **Create/Delete**: O(1) - memory allocation/deallocation

### Memory Usage

Each file consumes:
- `sizeof(struct ramfs_node)` (~120 bytes)
- Actual file size (rn_buf)
- Filename length (rn_name)

**Example calculation:**
```
1000 files of 1KB each:
  Nodes: 1000 * 120 bytes = 120 KB
  Data: 1000 * 1 KB = 1000 KB
  Names: 1000 * 16 bytes avg = 16 KB
  Total: ~1136 KB
```

### Scalability

RamFS works well for:
- Small to medium file counts (< 10,000 files)
- Small to medium file sizes (< 10 MB per file)
- Flat directory structures (< 1000 entries per directory)

For larger workloads, consider alternative filesystems.

## Comparison with Other Filesystems

| Feature | RamFS | 9pfs | DevFS |
|---------|-------|------|-------|
| Speed | Fastest | Network-dependent | Fast |
| Persistence | None | Persistent (host) | N/A |
| Memory usage | High | Low | Minimal |
| Setup complexity | Simple | Moderate | Simple |
| Best for | Temp files, cache | Shared storage | Device access |

## Best Practices

1. **Use for temporary data**: Don't rely on RamFS for anything that needs to survive a reboot
2. **Monitor memory**: Keep track of memory usage to avoid exhaustion
3. **Combine with persistent FS**: Use RamFS for speed, periodically flush to 9pfs or other persistent storage
4. **Limit file sizes**: Keep individual files reasonably sized
5. **Clean up**: Remove files when no longer needed to reclaim memory

## Troubleshooting

### Out of Memory

**Symptom:** File creation fails with ENOMEM

**Solutions:**
- Increase application memory allocation
- Delete unused files to free memory
- Use smaller files or fewer files
- Consider alternative filesystem for large data

### Performance Degradation

**Issue:** Operations slow down with many files

**Cause:** Linear directory search becomes expensive

**Solution:** 
- Use shallow directory hierarchies
- Split files across multiple directories
- Consider alternative filesystem for large file counts

## Related Libraries

- [posix-vfs](/libraries/vfs) - Virtual file system layer
- [9pfs](/libraries/9pfs) - Persistent, network-based filesystem
- [devfs](/libraries/devfs) - Device filesystem

## References

- Source: `lib/ramfs/` in Unikraft repository
- Header: `lib/ramfs/ramfs.h`
